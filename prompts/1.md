You are building a mobile phone game app inspired by lateral-thinking / enigma games (yes/no mystery solving).

Core Game Concept

Each game is based on a story/enigma.

Each story has two distinct parts:

Public Plot

Short, intriguing description.

Read aloud to players.

Detailed Solution

Full explanation.

Hidden from players; visible only to the Game Master.

Roles

Game Master (GM)

Selects a story.

Sees both public plot and detailed solution.

Reads the public plot aloud.

Answers questions with Yes / No / Irrelevant only.

Players

Ask yes/no questions.

Goal: infer the detailed solution.

App Flow Requirements

Onboarding

Skippable.

Explains rules, roles, and win condition.

Story Selection

List or grid of stories.

Used only by the GM.

Shows title and optional difficulty.

Story Card

Represented as a flippable card.

Front: Public Plot.

Back: Detailed Solution.

Back side requires an intentional reveal action.

Technical Choices (Mandatory)

Framework: React Native

Tooling: Expo

Language: TypeScript

Platform: iOS + Android

State: Local-only (no backend, no auth)

Data source: Local static data (JSON or TS file)

Architecture Requirement

Use a domain-oriented (feature-first) file architecture, not a layer-based one.

Organize the code by business domains, not by technical type.

Each domain should encapsulate:

UI components

Screens

Hooks / state

Types / models

Domain logic

Shared, cross-domain utilities should live in a clearly separated shared or core domain.

Example domains (not mandatory, but illustrative):

onboarding

stories

game

shared (UI primitives, theme, common utils)

Avoid global components/, screens/, or hooks/ folders unless they are explicitly shared across domains.

Design & UX Constraints

Designed for local, in-person play on one device.

Large text and simple layouts for group readability.

Strong spoiler protection (confirm before revealing solution).

No timers, no scoring, no networking.

Lightweight animations (especially for card flip).

What to Produce

Domain-oriented folder structure (with rationale)

TypeScript data models

Navigation structure

Key components (especially the flippable story card)

Example code snippets where relevant

Sample story data (at least one full story)

Clear assumptions when requirements are ambiguous

If something is unclear, make a sensible assumption and document it briefly.

If you want, I can next:

Lock down Expo Router vs React Navigation

Define exact domain boundaries

Generate a ready-to-run Expo starter with folders + sample code

Add testing strategy aligned with domain architecture

Just tell me what you want Claude to generate next ✨

Review this part:
"Example domains (not mandatory, but illustrative):

onboarding

stories

game

shared (UI primitives, theme, common utils)"

domains shoudl be under src/domain
shared logic should be under src/ui, src/technical, ...

Good catch — you’re right, that wording was slightly misleading for a strict domain-oriented setup.

Here’s a clean, corrected version that you can drop straight into the prompt. It clarifies boundaries and prevents Claude from dumping “shared” stuff into the domain layer.

Architecture Requirement (Revised)

Use a domain-oriented (feature-first) file architecture.

Domain Layer

All business domains must live under:

src/domain/


Each domain represents a business concept, not a technical concern.

Domains encapsulate:

Screens

Domain-specific UI components

Hooks / state

Domain models and logic

Example domains (illustrative, not mandatory):

src/domain/
  onboarding/
  stories/
  game/


Do not place generic UI, technical utilities, or cross-cutting concerns inside domains.

Shared & Cross-Cutting Layers

Shared logic must be separated by responsibility, not mixed into domains.

UI layer

src/ui/
  components/      // Buttons, cards, typography, layout primitives
  theme/           // Colors, spacing, typography


Technical / infrastructure layer

src/technical/
  navigation/
  storage/
  animations/
  analytics/       // if any


Common utilities (non-domain)

src/utils/


Domains may consume these layers but must not own or define them.

Dependency Direction Rules

domain → can depend on → ui, technical, utils

ui, technical, utils → must NOT depend on → domain

Domains must not import from each other directly (communicate via navigation or explicit contracts if needed)